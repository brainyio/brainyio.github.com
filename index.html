<!DOCTYPE html>
<html lang="en">

  <head>

    <meta charset="utf-8">
    <title>brainy.io</title>

    <link rel="stylesheet" href="/css/main.css">

  </head>

  <body>

    <div id="sidebar">

      <h4><a href="#">brainy (0.0.2)</a></h4>
      <ul>
        <li><a href="http://github.com/brainyio" rel="external" target="_blank">on GitHub</a></li>
      </ul>

      <h4><a href="#introduction">introduction</a></h4>

      <h4><a href="#api">api</a></h4>
      <ul>
        <li><a href="#api-models">models</a></li>
        <li><a href="#api-collections">collections</a></li>
      </ul>

      <h4><a href="#resources">resources</a></h4>
      <ul>
        <li><a href="#resources-idAttribute">idAttribute</a></li>
        <li><a href="#resources-url">url</a></li>
        <li><a href="#resources-urlRoot">urlRoot</a></li>
        <li><a href="#resources-fetch">fetch</a></li>
        <li><a href="#resources-validate">validate</a></li>
      </ul>

    </div>

    <div id="content">

      <h1>brainy.io</h1>

      <p>brainy is a set of tools for sharing <a href="http://backbonejs.org">Backbone</a> code between the client and the server. brainy allows you to write a Backbone client application without regard for the server. it creates the server for you.</p>

      <p>because it relies on REST and Backbone best practices, if you are familiar with both, you can create a brainy application.</p>

      <h2 id="introduction">introduction</h2>

      <p>when writing a front-end web application with Backbone, you are typically targeting some remote api. for rapid prototyping this poses two problems. first, you are rewriting models that likely have very similar definitions on the server. secondly, of course, it requires you have an api.</p>

      <p>brainy solves these problems by analyzing your Backbone models and collections (<a href="#resources">resources</a>), and creating the <a href="#api">api</a> they require.</p>

      <p>if you've not already, try <a href="https://github.com/brainyio/brainy-server/wiki/creating-a-brainy-application" target="_blank" st>creating a brainy application</a>.</p>

      <h2 id="api">api</h2>

      <p>when you start brainy it will create a RESTful API based on the (<a href="#resources">resources</a>) it's given. collections and models expose different endpoints and support different HTTP methods. the endpoint names reflect url and urlRoot properties of collections and models respectively.</p>

      <p>because your resources are shared between the client and server, the resource methods you define (fetch, save, etc) are run in both contexts. this is useful for scenarios like <a href="#resources-validate">validation</a>. this can be acheived by overriding <em>save</em>, <em>destroy</em> etc. to return errors if some condition is not satisfied, which will be verified by the client and the server.</p>

      <h3 id="api-models">models</h3>

      <p>when given a model, brainy will create the following HTTP endpoints for creating, reading, updating, and deleting models.</p>

      <p><strong>POST /:urlRoot</strong></p>

      <p>creates and returns a new model, or 400 if the model is invalid. model attributes should be passed in through the request body.</p>

      <p><strong>GET /:urlRoot/:id</strong></p>

      <p>returns a single model, or 404 if not found. additional parameters passed through in the querystring are interpreted as a mongodb query. if a query is used, the model will only be returned if it matches that query.</p>

      <p><strong>PUT /:urlRoot/:id</strong></p>

      <p>updates and returns the updated model, or 400 if the model is invalid. model attributes should be passed in through the request body.</p>

      <p><strong>DELETE /:urlRoot/:id</strong></p>

      <p>deletes a model and returns 200, or 404 if the model is not found.</p>

      <h3 id="api-collections">collections</h3>

      <p>when given a collection, brainy will create an HTTP endpoint for reading and querying models as a collection.</p>

      <p><strong>GET /:url</strong></p>

      <p>returns the entire collection of models, or [] if empty. additional parameters passed in the querystring are interpreted as a mongodb query. if a query is used, the collection will only return models that satisfy the query.</p>

      <h2 id="resources">resources</h2>

      <p>resources are simply any Backbone model or collection. because brainy doesn't modify Backbone api in any way, resources will behave as expected in the browser. brainy instead creates an additional context on the server in which your resources can operate.</p>

      <h3 id="resources-idAttribute">idAttribute</h3>

      <p>because brainy's primary data store is mongodb, you should assign <em>_id</em> to your model's idAttribute.</p>

      <pre>
        var Post = Backbone.Model.extend({
          idAttribute: '_id'
        });
      </pre>

      <h3 id="resources-urlRoot">urlRoot</h3>

      <p>similar to a collection's url, urlRoot is required for all models. urlRoot is used to infer a mongodb collection name and expose HTTP endpoints.</p>

      <pre>
        var Post = Backbone.Model.extend({
          idAttribute: '_id',
          urlRoot: '/posts'
        });
      </pre>

      <h3 id="resources-url">url</h3>

      <p>per usual Backbone practice, collections all require a url property or function. brainy relies on this well for two purposes: inferring a mongodb collection name, and exposing HTTP endpoints.</p>

      <pre>
        var PostsCollection = Backbone.Collection.extend({
          urlRoot: '/posts',
          model: Post
        });
      </pre>

      <h3 id="resources-fetch">fetch</h3>

      <p>resource fetch() functions behave as you'd expect them to in Backbone, but the nature of the HTTP api audments this function with an additional querying feature. by nature of jQuery's ajax method, the `data` value of `options` is serialized as a query string. the brainy api uses this query string to execute mongodb queries, meaning you can search collections through fetch:</p>

      <pre>
        var posts = new PostsCollection;
        posts.fetch({
          data: {
            text: {
              $regex: 'foo'
            }
          }
        });
      </pre>

      <h3 id="resources-validate">validate</h3>

      <p>validate, like all resource functions, runs on both the client and the server. if a model invalidates on the client, the request is not sent. if the request is sent, validate is run again by the server. this means your api can validate requests sent from any client.</p>

      <pre>
        var Post = Backbone.Model.extend({
          idAttribute: '_id',
          urlRoot: '/posts',
          validate: function(attrs) {
            var err = undefined;
            if (!attrs.text) {
              err = 'text cannot be empty';
            }
            return err;
          }
        });
      </pre>

      <p>in the example above, validate behaves as expected on the client, triggering the 'invalid' event on the model. validate on the server however, instead returns a 400 response code with the invalidation error in the response body.</p>

      <p>Backbone only supports synchronous validation. this means asynchronous validation (querying other resources, etc) cannot be acheived through validate. a fair work around to this is to add your asynchronous checks to save or fetch, only calling the super function if your check passes.</p>
    </div>

  </body>

</html>